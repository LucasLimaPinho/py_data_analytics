# Python é uma linguagem interpretada - o que o faz rodar de forma mais lenta
# do que um código de linguagem compilada como C++ ou Java.

# DataFrame é orientado a colunas, estrutura de dados tabular, com labels
# tanto para linhas quanto para colunas
# Series -> objeto array UNIDIMENSIONAL com rótulo
# Para dados numéricos, os arrays NumPy são mais eficientes para armazenar 
# e manipular dados do que as outras estruturas de dados embutidas (built-in)
# Além do mais, as bibliotecas escritas em uma linguagem de baixo nível, como
# C ou Fortran, podem operar em dados armazenados em um arram NumPy sem 
# copiar dados para outra representação em memória.

# Pandas combina as ideias de processamento de alto desempenho de arrays da NumPy
# com os recursos flexíveis de manipulação de dados das planilhas e dos
# banco de dados relacionais (como o SQL). Ele disnponibiliza uma funcionalidade
# sofisticada de indexação para facilitar a reformatação, a manipulação,
# as agregações e a seleção de subconjunto de dados.

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import scipy
import sklearn
import statsmodels as sm
import seaborn as sns
import timeit
%clear

# Lista b -> b.append, b. clear, b.copy, b.count, b.insert,
# b.pop, b.remove, b.reverse, b.sort

# Módulo datetime -->> datetime.date, datetime.datetime, datetime.datetime_CAPI
# datetime.MAXYEAR, datetime.MINYEAR, datetime.time, datetime.timedelta,
# datetime.timezone, datetime.tzinfo

b = [1,2,3]
b?
%clear
def add_numbers(a,b):
    return a + b
add_numbers?
add_numbers??

a = [1,2,3]
b = a
a
b
a.append(4)   
a
b 
# OBSERVAR que em Python agora 'b = a' se referem ao mesmo objeto
# e não somente b recebeu os valores [1,2,3]. A atribuição também é chamada
# de vinculação (binding), pois estamos vinculando um nome a um objeto.
# Quando passamos objetos como argumentos para uma função, novas variáveis
# locais são criadas para referenciar os objetos originais, sem qualquer cópia.
# Se você vincular um novo objeto a uma variável em uma função,
# essa alteração não se refletirá no escopo-pai. ASsim é possível alterar
# o conteúdo interno de um argumento mutável.

# Objetos em Python geralmente têm tantos atributos (outros objetos Python
# "armazenados" dentro do objeto) quando métodos (funções associadas a um objeto
# que podem ter acesso a seus dados internos). Ambos são acessados 
# por meio da sintaxe obj.nome_do_atributo

# Atributos e métodos também podem ser acessados pelo nome usando a função
# getattr

##### DUCK TYPING: "Se anda como pato e faz quack como um pato, então é um pato"

def isiterable(obj):
    try:
        iter(obj)
        return True
    except TypeError:
        return False

isiterable('a string')
isiterable([1,2,3])
isiterable(5)

if not isintance(x,list) and isiterable(x):
    x = list(x)

a = [1,2,3]
c = list(a) # list sempre cria uma nova lista Python (cópia)
a is c
a == c
d = """this is a multiple
string that spans
multiple 
lines"""
print(d)
d.count('\n')
a = 'this is a string'
a[10]
for iter in a:
    print(iter)
for iter in enumerate(a):
    print(iter)
x = 5.6
y = str(x)

a = 'this is the first half'
b = ' and this is the second half'
print(a+b)
a + b
# Os objetos string têm um método FORMAT que pode ser usado para
# substituir argumentos formatados na string, gerando uma nova string:

template = '{0:.2f} {1:s} are worth US${2:d}'

# {0:.2f} significa formatar o primeiro argumento como um número de ponto
# flutuante com duas casas decimais
# {1:s} significa formatar o segundo argumento como uma string
# {2:d} significa formatar o terceiro argumento como um inteiro exato

template.format(4.5560,'Argentine Pesos',1)

# Converter string Unicode para sua representação em bytes UTF-8 usando
# o método encode

val = 'español'
val
val_utf8 = val.encode('utf-8')
val_utf8
type(val_utf8)
val_utf8.decode('utf-8')
val.encode('latin1')

# Casting de tipos

# Os tipos str, bool, int e float também são funções que podem ser usadas 
# para cast de valores para esses tipos

s = '3.14159'
type(s)
fval = float(s)
fval
type(fval)
int(fval)
bool(fval)
bool(0)

# None pode ser usado como valor default para argumento de função

def add_and_maybe_multiply(a,b,c=None):
    result= a+b
    if c is not None:
        result = result * c
    return result
add_and_maybe_multiply(3,5)
add_and_maybe_multiply(3,5,3)

### Datas e Horas

# O módulo built-on DATETIME de Python disponiibliza os tipos 
# datetime, date e time
# O tipo datetime, como você pode imaginar, combina as informações armazenadas
# em date e time e é o tipo mais comumente utilizado:

from datetime import datetime, date, time
dt = datetime(2011,10,29,20,30,21)
dt.day
dt.minute
dt.hour
dt.second
dt.date()
# Dada uma instância de datetime, você pode extrair os objetos date e time
# equivalentes chamando os métodos no datetime

dt.time()
dt.strftime('%m/%d/%Y %H:%M')
dt.strptime('20091031', '%Y%m%d')
dt.replace(minute=0,second=0)
dt2 = datetime(2011,11,15,22,30)
delta = dt2 - dt
delta
type(delta)
dt + delta

string = 'Squeezing Data 4 a living'
del seq
for i in range(len(string)):
    print(i)

# Tuplas: sequências imutáveis de tamanho fixo.
tup = 4,5,6
type(tup)
tup
nested_tup = (4,5,6), (7,8)
nested_tup
len(nested_tup)
tup = tuple('string')
len(tup)
tup
tup[0]
# Não podemos alterar o valor das tuplas -> coleções imutáveis
tup2 = tuple(['foo',[1,2],True])
tup2[2] = False # Gera erro por ser uma coleção imutável
# Se um objeto de uma tupla for mutável, por exemplo, uma lista, você
# pode alterá-lo in place.
tup2[1] # -> é a lista [1,2] que é uma coleção mutável.
tup2[1].append(3)
tup2
#Concatenação de tuplas utilizando operador +
# Multiplicar uma tupla por um inteiro, como ocorre com as listas,
# tem o efeito de concatenar essa quantidade de cópias da tupla:
tup3 = (4, None, 'foo') + (6,0) + ('bar',)
tup3
tup3*3
('foo','bar')*4
# DESEMPACOTANDO TUPLAS

tup = (4,5,6)
a,b,c, = tup
a
b
c
tup = 4,5,(6,7)
a,b,(c,d) = tup
d
# usando desempacotamento para swap;

values = 1,2,3,4,5
a,b,*resto = values
a,b
resto
# AS vezes por convenção utilizamos o underscore quando não usaremos o resto

a,b,*_ = values
a,b
_
b_list = list(values)
b_list
type(b_list)
b_list[1] = 'peekaboo' # lista é mutável, agoro posso realizar alteração.
b_list
b_list.append('dwarf');b_list
b_list.insert(1,'red');b_list
b_list.insert(3,'posição3');b_list
# insert é custosa do ponto de vista de processamento se comparada com append.
# collections.deque pode ser melhor para inserir ou retirar elementos do começo
# e fim de listas.

b_list.pop(2)
b_list
b_list.append('foo');b_list
b_list.remove('foo');b_list
'dwarf' in b_list
'dwarf' not in b_list
# Verfificar se uma lista contém um valor é muito mais lendo do que fazer 
# isso com dicionários e conjuntos, pois Python faz uma verificação linear
# nos valores de lista, enquanto é capaz de verificar os outros tipos (com 
#base em tabelas hash) em um tempo constante.

b_list.extend(['banco','fintech','dot','instituto']);b_list
# Usar .extend é preferível em relação a concatenar com operador +
b_list[0] = str(b_list[0]);b_list[3] = str(b_list[3]); b_list[4] = str(b_list[4]); b_list[5] = str(b_list[5])

b_list.sort(key=len);b_list
import bisect
# bisect implementa a busca binária e inserção em uma lista ordenada. 
# bisect.bisect encontra o local em que um elemento deve ser inserido para manter a lista 
# ordenada, enquanto bisect.insort insere o elemento nesse local.

c = [1,2,2,2,3,4,7]
bisect.bisect(c,2)
bisect.bisect(c,5)
bisect.insort(c,6)
c
# SLICING
seq = [7,2,3,7,5,6,0,1]
seq[1:5]
seq[3:4] = [6,3]
seq[:5]
seq[3:]
seq[-4:]
seq[-6:-2]
seq[::2]
seq[::-1] # Inverte uma lista ou uma tupla!

# ENUMERATE: querer manter o controle do índice do item atual quando iteramos
# por uma sequência é comum. Enumerate devolve uma sequência de tuplas.

alguma_lista = ['foo','bar','baz']
mapping = {}
for i,v in enumerate(alguma_lista):
    mapping[v]=i
mapping

# ZIP pareia os elementos de uma série de listas, tuplas ou outras sequências para
# criar uma lista de tuplas:

seq1 = ['foo','bar','baz']; seq2 = ['one','two','three']
zipped = zip(seq1,seq2)
zipped
list(zipped)
# zip pode aceitar um número arbitrário de sequências, e o número de elementos que ele gera é 
# determinado pela sequência mais curta.

seq3 = [True,False]
zipped = zip(seq1,seq2,seq3)
list(zipped)

for i,(a,b) in enumerate(zip(seq1,seq2)):
    print('{0}: {1}, {2}'.format(i,a,b))


# dict provavelmente é a estrutura de dados embutida mais importante de Python.
# um nome mais comum para ele é hash map ou array associativo. 
# consiste em uma coleção de pares de chave-valor (KVP) de tamanho flexível
# em que chave e valor são objetos Python. Lidando com dicionário, argumento deve ser
# tipicamente, a chave.
empty_dict = {}
d1 = {'a': 'some value', 'b': [1,2,3,4]}
d1['b']
d1['a']
d1[7] = 'an integer'
d1
'b' in d1 # True
b in d1 # False

d1[5] = 'some value';d1
d1['dummy'] = 'another value'; d1
del d1[5]; d1
ret = d1.pop('dummy'); ret # pop retorna o value e recebe a key para apagar.
d1.keys()
list(d1.keys())
list(d1.values())
d1.update({'b': 'foo', 'c': 12})
d1

# value = some_dict.get(key,default_value) -> by default, get vai devolver None se a chave não
# estiver presente. some_dict.pop() irá lançar uma exceção caso a chave não esteja presente.

words = ['apple','bat','bar','atom','book']
by_letter = {}
for word in words:
    letter = word[0]
    if letter not in by_letter:
        by_letter[letter] = [word]
    else:
        by_letter[letter].append(word)

# O método de dicionário setdefault serve exatamente para essa finalidade. 
# o laço for anterior pode ser reescrito assim:

for word in words:
    letter = word[0]
    by_letter.setdefault(letter,[]).append(word)

%reset
%clear
# os OBJETOS HASHABLE são imutáveis. Portanto, listas que são mutáveis são unhashable. 
hash('string) #OK porque string é imutável - hashable
hash((1,2,(2,3))) #OK porque tupla é imutável - hashable
hash((1,2,[2,3])) #NOK -> listas são mutáveis e, portanto, não hashable.

# LIST COMPREHENSIONS (listcomps): permitem que você componha uma nova lista de nmodo conciso, filtrando os elementos de uma coleção,
# transformando os elementos aos passar o filtro, com uma expressão concisa



# forma padrão de listcomp ---> [expr for val in collection if condition]

strings = ['a', 'as', 'bat', 'car', 'dove', 'python']
listcomp = [x.upper() for x in strings if len(x) > 2]


# dict_comp = {expr-chave : expr-valor for value in collection if condition}
# set_comp = {expr for value in collection if condition}

loc_mapping = {val : index for index, val in enumerate(strings)}
loc_mapping

# funções em python são objetos. Facilita remover espaços em branco, símbolos de pontuação, criar um padrão para ter um uso adequado de 
# letras maiúsculas ou não no início das palavras. Uma forma de fazer isso é usar métodos embutidos de string, junto com o módulo re
# da bibioleca-padrão para expressões regulares

import re
states = ['Alab?ama',
          'Georgia!',
          'georgia',
          'FlOrida',
          'south carolina####',
          'West Virginia?']
def clean_strings(strings):
    result = []
    for value in strings:
        value = value.strip()
        value = re.sub('[!#?]','',value)        
        value = value.replace(" ","")
        value = value.title()
        result.append(value)
    return result

clean_strings(states)

# FUNÇÕES ANÔNIMAS (lambdas): Python oferece suporte para funções anônimas ou lambdas - uma forma de escrever funções constituídas 
# de uma única instrução, cujo resultado é o valor de retorno. Lambda significa "estamos declarando uma função anônima"
# Em Data Science, há muitos casos em que funções de transformação de dados aceitarão funções como argumentos -
# daí a necessidade de termos que usar funções lambdas. Geralmente exige-se menos digitação (e é mais claro) passar
# uma função lambda, em oposição a escrever uma declaração de função completa ou até mesmo abrir a função lambda a uma variável local.

 # CURRYING: aplicação parcial de argumentos derivando novas funções a partir de funções existentes.
 
 def add_numbers(x,y):
                return x + y
 add_five = lambda y: add_numbers(5,y) # função de uma variável derivada da função existente -> currying.
 # Dizemos que o segundo argumento de add_numbers sofreu currying.
 
 from functools import partial
 add_five = partial(add_numbers,5)
 # EXPRESSÕES GERADORAS: feitas utilizando parênteses ao invés de colchetes na sintaxe de listcomps.
 # Geradores e expressões geradores atuam de forma lazy e somente geram quando chamados.
 # Expressões geradores podem ser usadas no lugar de listcomps como argumentos de função em muitos casos.
 
 gen = (x ** 2 for x in range(100))
 
 ## Módulo ITERTOOLS
 
 # O módulo itertools da biblioteca-padrão tem uma coleção de geradores para muitos algoritmos comuns de dados.
 # Por exemplo, groupby aceita qualquer sequência e uma função, agrupando elementos consecutivos da sequeência de acordo
 # com o valor de retorno da função.
 
 import itertools
 first_letter = lambda x: x[0]
 names = ['Alan', 'Adam', 'Wes', 'Will', 'Albert', 'Steven']
 for letter, names in itertools.groupby(names,first_letter):
        print(letter,list(names)) # names é um gerador
   
######## NUMPY: arrays e processamento vetorial.]
# 1) ndarray: um array multidimensional eficaz que oferece operações aritméticas
     #rápidas, orientadas a arrays, e recursos flexíveis de broadcasting
# 2) funções matemáticas para operações rápidas de arrays de dados inteiros, 
     # sem que seja necessário escrever laços
# 3) ferramentas para ler/escrever dados de array em disco e trabalhar com 
     # arquivos mapeados em memória
# 4) recursos para álgebra linear, geração de números aleatórios e transformadas
     # de Fourier
# 5) uma API C para conectar o NumPy a bibliotecas escritas em C, C++ ou FORTRAN
# esse recurso fez de Python uma linguagem preferida para encapsular bases de código
# legadas em C/C++/FORTRAN, oferecendo-lhes uma interface dinâmica e fácil
# broadcasting é um dos recursos mais avançados de Numerical Python (NumPy)     
%reset
%clear
import numpy as np
     # NumPy oferece operações rápidas em arrays vetorizados para tratamento 
# e limpeza de dados, geração de subconjuntos e filtragem, transformações e
# outros tipos de processamentos.]

# algoritmos comuns para arrays como ordenação, 
#unicidade e operações de conjunto

# estatísticas descritivas eficazes e agregação/sintetização de dados;

# alinhamento de dados e manipulações de dados relacionais
# para combinar e juntar conjuntos de dados heterogêneos;

# expressão de lógica condicionak na forma de expressões de array
# em vez de laços com ramos if-else-elif]

# manipulações de dados em grupos (agregação, transformação e aplicação de função)

# pandas é mais utilizado em dados tabulares. O pandas também oferece algumas funcionalidades mais específicas de domínios,
# como manipulação de séries temporais, que não estão presentes no NumPy.

######## NUMPY: arrays e processamento vetorial.]
# 1) ndarray: um array multidimensional eficaz que oferece operações aritméticas
     #rápidas, orientadas a arrays, e recursos flexíveis de broadcasting
# 2) funções matemáticas para operações rápidas de arrays de dados inteiros, 
     # sem que seja necessário escrever laços
# 3) ferramentas para ler/escrever dados de array em disco e trabalhar com 
     # arquivos mapeados em memória
# 4) recursos para álgebra linear, geração de números aleatórios e transformadas
     # de Fourier
# 5) uma API C para conectar o NumPy a bibliotecas escritas em C, C++ ou FORTRAN
# esse recurso fez de Python uma linguagem preferida para encapsular bases de código
# legadas em C/C++/FORTRAN, oferecendo-lhes uma interface dinâmica e fácil
# broadcasting é um dos recursos mais avançados de Numerical Python (NumPy)     
%reset
%clear
import numpy as np
     # NumPy oferece operações rápidas em arrays vetorizados para tratamento 
# e limpeza de dados, geração de subconjuntos e filtragem, transformações e
# outros tipos de processamentos.]

# algoritmos comuns para arrays como ordenação, 
#unicidade e operações de conjunto

# estatísticas descritivas eficazes e agregação/sintetização de dados;

# alinhamento de dados e manipulações de dados relacionais
# para combinar e juntar conjuntos de dados heterogêneos;

# expressão de lógica condicionak na forma de expressões de array
# em vez de laços com ramos if-else-elif]

# manipulações de dados em grupos (agregação, transformação e aplicação de função)

# Comparação de desempenho de um array NumPy com 10^6 milhão de inteiros
# e uma lista equivalente em Python

my_arr = np.arange(10**6)
my_list = list(range(10**6))
%time for _ in range (10): my_arr2 = my_arr*2 
%time for _ in range (10): my_list2 = [x*2 for x in my_list]

# Algoritmos baseados no NumPy geralmente são de 10 a 100 vezes mais rápidos (ou mais) do que suas contrapartidas em Python puro,
# além de utilizarem significativamente menos memória.

# NDARRAY no NumPy: um objeto array multidimensional

# contêiner rápido e flexível para conjuntos de dados grandes em Python. Arrays permitem realizar operações matemáticas
# em blocos inteiros de dados usando uma sintaxe semelhante às operações equivalentes entre elementos escalares.

# um ndarray é um contêiner genérico multidimensional para dados homogêneos; isso significa que todos os elementos
# DEVEM SER DO MESMO TIPO. Todo array tem um SHAPE, isto é, uma tipla que indica o tamanho de cada dimensão, e um
# DTYPE, que é um objeto que descreve o tipo de dado do array.
# SHAPE e DTYPE -> coisa de array; Para ter shape precisa ser multidimensional. Dict não tem shape.

data.shape
data.dtype

my_arr = np.arange(10**6)
my_list = list(range(10**6))
%time for _ in range (10): my_arr2 = my_arr*2 
%time for _ in range (10): my_list2 = [x*2 for x in my_list]   

data = np.random.randn(2,3) # dados com distribuição normal. 2 linhas, 3 colunas
data
data *10
data + data     
data.shape
data.dtype

data1 = [6,7.5,8,0,1]
arr1 = np.array(data1)
arr1

data2 = [[1,2,3,4],[5,6,7,8]] # vírgula separa a linha na formação do array
len(data2)
type(data2)
arr2 = np.array(data2)
type(arr2)
len(arr2)
arr2.size
arr2.shape
arr2.dtype
arr2.ndim # importante para verificar quantidade de atributos em data science
arr2
np.zeros(10)
np.ones(5)
np.zeros((3,5))
np.empty((2,3,2))
np.eye(3)
np.full(5,3)

# Os dtyés são um dos motivos para a flexibilidade do NumPy em interagir com dados provenientes de outros sistemas. 
# Na maioria dos casos, eles ofrecem um mapeamento direto para um disco subjacente ou uma representação em memória,
# o que facilita ler e escrever streams de dados binários em disco e também se conectar com um código escrito
# em linguagem de baixo nível como C ou Fortran. 

# Cast np.array
arr = np.array([1,2,3,4,5])
arr.dtype
float_arr = arr.astype(np.float64)
float_arr.dtype
float_arr


arr = np.array([3.7, -1.2, -2.6, 0.5, 12.9, 10.1])
arr
int_arr = arr.astype(np.int32)
int_arr
# Se, por algum motivo, o casting falhar (como no caso de uma string que não possa ser convertida para float64),
# um ValueError será gerado.
# Chamar astype sempre cria um novo array (uma cópia de dados), mesmo que o novo dtype seja igual ao dtype antigo.
# Aritméticas com arrays NumPy: permitem expressar operações em lote nos dados, sem escrever qualquer laço for.

import numpy as np
arr = np.array([[1.,2.,3.],
               [4.,5.,6.]]); arr.dtype
arr.shape
arr
arr * arr
arr - arr
1 / arr
arr ** 0.5

arr2 = np.array([[0.,4.,1.],
                 [7.,2.,12.]]); arr2

arr2 > arr

# As operações entre arrays de tamanhos distintos são chamados de BROADCASTING.
# Atribuir valor escalar a uma fatia, o valor será propagado (sofrerá broadcast a partir daí) para toda a seleção.
# As fatias de arrays são VISUALIZAÇÕES do array original. Issto significa que os dados não são copiados e qualquer modificação
# na visualização se refletirá no array original.

arr = np.arange(10); arr
arr[5]
arr[5:8]
arr[5:8] = 12; arr
arr_slice = arr[5:8]; arr_slice
arr_slice[1] = 12345; arr
# Quando faço alterações nos valores de arr_slice, as mudanças se refletem no array arr original.
arr_slice[:] = 64; arr
# Poderíamos ter sérios problemas de desempenho e de memória se o NumPy insistisse em sempre copiar dados, uma vez que
# iremos lidar com problemas de dados bem grandes.

# Se você quiser uma cópia de uma fatira de um ndarray em vez de ter uma visualização, será necessároi copiar explicitamente o array -
# por exemplo arr[5:8].copy()

arr = np.arange(10); arr
arr[5]
arr[5:8]
arr[5:8] = 12; arr
arr_slice = arr[5:8]; arr_slice
arr_slice[1] = 12345; arr
arr_slice[:] = 64; arr

arr2d = np.array([[1,2,3],
                  [4,5,6],
                  [7,8,9]]); arr2d[2]
arr2d[0,2]

arr3d = np.array([[[1,2,3],
                  [4,5,6]],
                  [[7,8,9],
                  [10,11,12]]]); arr3d
arr3d.shape
arr3d[0]
arr3d[1]
arr3d[0].shape
arr3d[1].shape
arr3d[0,0,2]
arr3d[0][0][2]
old_values = arr3d[0].copy()
arr3d[0] = 42
arr3d
arr3d[0] = old_values; arr3d

# Indexando com fatias

arr3d.shape
arr3d[0]
arr3d[1]
arr3d[0].shape
arr3d[1].shape
arr3d[0,0,2]
arr3d[0][0][2]
old_values = arr3d[0].copy()
arr3d[0] = 42
arr3d
arr3d[0] = old_values; arr3d
arr3d[1,0]
arr3d
arr3d[0,:1,:2]

# Indexação booleana

# Assim como nas operações aritméticas, as comparações (como ==) com arrays também são vetorizadas. 

names = np.array(['Bob','Joe','Will','Bob','Will','Joe','Joe'])
names.shape
data = np.random.randn(7,4); data.shape
data
names
names == 'Bob'
type(names=='Bob')
data[names=='Bob'] # Devolve os índices em que names == 'Bob'
# em ndarray do NumPy, os itens passados como argumentos se referem às linhas

# O array booleano deve ter o mesmo tamanho do eixo do array que ele está indexado. Você pode até mesmo misturar e fazer a
# correspondência entre arrays booleanos e fatias ou inteiros (ou sequência de inteiros)

# em ndarray do NumPy, os itens passados como argumentos se referem às linhas
data[names=='Bob',2:]
data[names=='Bob',3]
data[~(names=='Bob')] # índices em que data não é 'Bob'. No caso, 7 -2 =5
data[~(names=='Bob')].shape
cond = names == 'Bob'
data[~cond]
mask = (names=='Bob') | (names == 'Will')
mask
data[mask]
# As palavras reservadas and e or de Python não funcionam com arrays booleanos. Utilize & (and) | (or) em seu lugar.
data[data<0] = 0; data
data[names != 'Joe'] = 7; data

# Indexação Sofisticada (fancy indexing)

# Termo adotado pelo NumPy para descrever a indexação usando arrays de inteiros. Suponha que tivéssemos um array de 8x4.

arr = np.empty((8,4))
arr = np.empty((8,4))
for i in range(8):
    arr[i] = i
arr
arr[[4,3,0,6]]
arr[[-3,-5,-7]] # Usar índices negativos seleciona as linhas a partir do final (a indexação começa em -1 e não em 0).

# Passar vários índices de array faz algo um pouco diferente; a instrução seleciona um array unidimensional de elementos
# correspondentes a cada tupla de índices:


arr = np.arange(32).reshape((8,4))
arr
arr = np.arange(32).reshape((4,8)); arr
arr = np.arange(32).reshape((8,4)); arr
arr[[1,5,7,2], [0,3,1,2]] # Nesse caspo, os elementos (1,0), (5,3), (7,1), (2,2) foram selecionados. Independente
# de quantas dimensoes o array tiver, o resultado da indexação sofisticada sempre será unidimensional.
# A indexação sofisticada, de modo diferente do slicing, sempre copia os dados para um novo array

arr[[1,5,7,2][:,[0,3,1,2]]

# Transposição de arrays e troca de eixos.

# A transposição devolve uma visualização dos dados subjacentes, sem copiar nada. Os arrays possuem o método transpose.

arr = np.array([[0,1,2,3,4],
       [5,6,7,8,9],
       [10,11,12,13,14]])
arr.T
arr.T.shape
arr = np.random.randn(6,3)
np.dot(arr.T,arr)

# np.dot é o PRODUTO INTERNO (INNER PRODUCT)

arr = np.arange(16).reshape(2,2,4)
arr
arr.transpose(1,0,2)
arr
arr.swapaxes(1,2)

arr = np.random.randn(7)*5
remainder , whole_part = np.modf(arr)
remainder
whole_part

# UFUNCs permitem utilizar argumento opcional out que lhes permite atuar in-place nos arrays.

# Pg.146 traz uma lista de ufuncs aplicadas a arrays como abs, fabs, sqrt, square, exp, log, log10, log2
# log1p, sign, floor, ceil, rint, modf, isnan, isfinite, isinf, cos, sin, cosh, sinh, tan, tanh,

# arccos, arccosh, arcsin, arcsinh, arctan, arctanh,
#logical_not

# Programação Orientada a arrays: evitar escrita de laços; concise expressions;
# a prática de substituição de laços explícitos por expressões de arrays é chamada de vetorização (vectorization).
# é mais rápido de uma a duas ordens de grandeza que os equivalentes em Python puro.

points = np.arange(-5,5,0.01) # 1000 pontos igualmente espaçados
xs, ys = np.meshgrid(points,points)
ys
xs

import matplotlib.pyplot as plt
z = np.sqrt(xs**2 + ys **2)
plt.imshow(z,cmap=plt.cm.gray);plt.colorbar()
plt.title("Image plot of $\sqrt {x^2 + y^2}$ for a grid of values")

# numpy.where é uma função ternária - versão vetorizada x if condition else y. 

xarr = np.array([1.1,1.2,1.3,1.4,1.5])
yarr = np.array([2.1,2.2,2.3,2.4,2.5])
cond = np.array([True,False,True,True,False])

# Versão com laço explícito x if conditio else y

result = [(x if c else y) for x,y,c in zip(xarr,yarr,cond)]
result

# Versão vetorizada com função ternária numpy.where

result = np.where(cond, xarr, yarr)
result
# O segundo e o terceiro argumento de np.where não precisam necessariamente 
# ser arrays; um deles, ou ambos, podem ser escalares.

# O segundo e o terceiro argumento de np.where não precisam necessariamente 
# ser arrays; um deles, ou ambos, podem ser escalares. Um uso típico de where em análise de dados
# é aquele em que geramos um novo array de valores com base em outro array.
# Suponha que você tenha uma matriz de dados gerados aleatoriamente e quisesse
# substituir todos os valores positivos por 2 e todos os negativos por -2.
# Fica fácil utilizando numpy.where.

arr = np.random.randn(4,4)
np.where(arr >0,2,-2)

arr = np.random.randn(5,4)
arr
arr.mean()
np.mean(arr)
arr.sum()
arr.mean(axis=1)
arr.sum(axis=0)
arr = no.array([0,1,2,3,4,5,6,7])
arr.cumsum()

arr = np.random.randn(100)
(arr>0).sum() # numero de valores positivos (deve ser próximo de 50)

# Há dois métodos adicionais, any e all, particularmente úteis para arrays booleanos.
# any testa se um ou mais valores em um array são True, enquanto all verifica
# se todos os valores são True.

bools = np.array([False,False,True,False])
bools.any()
bools.all()

